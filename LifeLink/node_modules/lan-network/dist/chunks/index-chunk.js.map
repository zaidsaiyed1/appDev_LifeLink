{"version":3,"file":"index-chunk.js","sources":["../../src/network.ts","../../src/dhcp.ts","../../src/route.ts","../../src/index.ts"],"sourcesContent":["import os from 'node:os';\nimport type { GatewayAssignment, NetworkAssignment } from './types';\n\nexport const DEFAULT_ASSIGNMENT: GatewayAssignment = {\n  iname: 'lo0',\n  address: '127.0.0.1',\n  netmask: '255.0.0.0',\n  family: 'IPv4',\n  mac: '00:00:00:00:00:00',\n  internal: true,\n  cidr: '127.0.0.1/8',\n  gateway: null,\n};\n\nexport const parseMacStr = (macStr: string): number[] =>\n  macStr\n    .split(':')\n    .slice(0, 16)\n    .map(seq => parseInt(seq, 16));\n\nexport const parseIpStr = (ipStr: string): number => {\n  const addr = ipStr\n    .split('.')\n    .slice(0, 4)\n    .map(seq => parseInt(seq, 10));\n  return addr[3] | (addr[2] << 8) | (addr[1] << 16) | (addr[0] << 24);\n};\n\nexport const toIpStr = (addr: number): string => {\n  const MASK = (1 << 8) - 1;\n  let ipStr = '';\n  ipStr += `${((addr >>> 24) & MASK).toString(10)}.`;\n  ipStr += `${((addr >>> 16) & MASK).toString(10)}.`;\n  ipStr += `${((addr >>> 8) & MASK).toString(10)}.`;\n  ipStr += (addr & MASK).toString(10);\n  return ipStr;\n};\n\nconst getSubnetPriority = (addr: string): number => {\n  if (addr.startsWith('192.')) return 5;\n  else if (addr.startsWith('172.')) return 4;\n  else if (addr.startsWith('10.')) return 3;\n  else if (addr.startsWith('100.')) return 2;\n  else if (addr.startsWith('127.')) return 1;\n  else return 0;\n};\n\n/** Determines if an assignment is internal (indicated by the flag or by a zeroed mac address) */\nexport const isInternal = (assignment: NetworkAssignment) =>\n  assignment.internal || parseMacStr(assignment.mac).every(x => !x);\n\nexport const interfaceAssignments = (): NetworkAssignment[] => {\n  const candidates: NetworkAssignment[] = [];\n  const interfaces = os.networkInterfaces();\n  for (const iname in interfaces) {\n    const assignments = interfaces[iname];\n    if (!assignments) continue;\n    for (const assignment of assignments) {\n      if (assignment.family !== 'IPv4') continue;\n      candidates.push({ ...assignment, iname });\n    }\n  }\n  return candidates.sort((a, b) => {\n    const priorityA = getSubnetPriority(a.address);\n    const priorityB = getSubnetPriority(b.address);\n    // Prioritise external interfaces, then sort by priority,\n    // when priority is equal, sort by raw IP values\n    const sortBy =\n      +isInternal(a) - +isInternal(b) ||\n      priorityB - priorityA ||\n      parseIpStr(b.address) - parseIpStr(a.address);\n    return sortBy;\n  });\n};\n\nexport const matchAssignment = (\n  candidates: NetworkAssignment[],\n  addr: string\n): GatewayAssignment | null => {\n  const rawAddr = parseIpStr(addr);\n  for (const candidate of candidates) {\n    const candidateAddr = parseIpStr(candidate.address);\n    if (rawAddr === candidateAddr) return { ...candidate, gateway: null };\n    const mask = parseIpStr(candidate.netmask);\n    if ((rawAddr & mask) === (candidateAddr & mask))\n      return { ...candidate, gateway: addr };\n  }\n  return null;\n};\n","import { randomBytes } from 'node:crypto';\nimport { createSocket } from 'node:dgram';\nimport { parseIpStr, toIpStr, parseMacStr } from './network';\nimport type { NetworkAssignment } from './types';\n\nclass DHCPTimeoutError extends TypeError {\n  code = 'ETIMEDOUT';\n}\n\nconst computeBroadcastAddress = (assignment: NetworkAssignment) => {\n  const address = parseIpStr(assignment.address);\n  const netmask = parseIpStr(assignment.netmask);\n  return toIpStr(address | ~netmask);\n};\n\nconst dhcpDiscoverPacket = (macStr: string) => {\n  const MAC_ADDRESS = new Uint8Array(16);\n  MAC_ADDRESS.set(parseMacStr(macStr));\n  const packet = new Uint8Array(244);\n  const XID = randomBytes(4);\n  packet[0] = 1; // op = request\n  packet[1] = 1; // hw_type = ethernet\n  packet[2] = 6; // hw_len = ethernet\n  packet[3] = 0; // hops = 0\n  packet.set(XID, 4);\n  // elapsed = 0 seconds [2 bytes]\n  packet[10] = 0x80; // flags = broadcast discovery [2 bytes]\n  // client IP = null [4 bytes]\n  // own IP = null [4 bytes]\n  // server IP = null [4 bytes]\n  // gateway IP = null [4 bytes]\n  packet.set(MAC_ADDRESS, 28);\n  // sname = null [64 bytes]\n  // boot file = null [128 bytes]\n  packet.set([0x63, 0x82, 0x53, 0x63], 236); // Magic cookie\n  packet.set([0x35, 0x01, 0x01, 0xff], 240); // Trailer\n  return packet;\n};\n\nconst DHCP_TIMEOUT = 250;\nconst DHCP_CLIENT_PORT = 68;\nconst DHCP_SERVER_PORT = 67;\n\nexport const dhcpDiscover = (\n  assignment: NetworkAssignment\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const broadcastAddress = computeBroadcastAddress(assignment);\n    const packet = dhcpDiscoverPacket(assignment.mac);\n    const timeout = setTimeout(() => {\n      reject(\n        new DHCPTimeoutError(\n          `Received no reply to DHCPDISCOVER in ${DHCP_TIMEOUT}ms`\n        )\n      );\n    }, DHCP_TIMEOUT);\n    const socket = createSocket(\n      { type: 'udp4', reuseAddr: true },\n      (_msg, rinfo) => {\n        clearTimeout(timeout);\n        resolve(rinfo.address);\n        socket.close();\n        socket.unref();\n      }\n    );\n    socket.on('error', error => {\n      clearTimeout(timeout);\n      reject(error);\n      socket.close();\n      socket.unref();\n    });\n    socket.bind(DHCP_CLIENT_PORT, () => {\n      socket.setBroadcast(true);\n      socket.setSendBufferSize(packet.length);\n      socket.send(\n        packet,\n        0,\n        packet.length,\n        DHCP_SERVER_PORT,\n        broadcastAddress,\n        error => {\n          if (error) reject(error);\n        }\n      );\n    });\n  });\n};\n","import { createSocket } from 'dgram';\n\nconst NOOP_PORT = 65535;\nconst NOOP_IP = '255.255.255.255';\nconst NO_ROUTE_IP = '0.0.0.0';\n\nclass DefaultRouteError extends TypeError {\n  code = 'ECONNABORT';\n}\n\nexport const probeDefaultRoute = (): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const socket = createSocket({ type: 'udp4', reuseAddr: true });\n    socket.on('error', error => {\n      reject(error);\n      socket.close();\n      socket.unref();\n    });\n    socket.connect(NOOP_PORT, NOOP_IP, () => {\n      const address = socket.address();\n      if (address && 'address' in address && address.address !== NO_ROUTE_IP) {\n        resolve(address.address);\n      } else {\n        reject(new DefaultRouteError('No route to host'));\n      }\n      socket.close();\n      socket.unref();\n    });\n  });\n};\n","import { spawnSync } from 'child_process';\nimport { dhcpDiscover } from './dhcp';\nimport { probeDefaultRoute } from './route';\nimport {\n  DEFAULT_ASSIGNMENT,\n  interfaceAssignments,\n  matchAssignment,\n  isInternal,\n} from './network';\nimport type { GatewayAssignment } from './types';\n\nexport async function lanNetwork(): Promise<GatewayAssignment> {\n  // Get IPv4 network assignments, sorted by:\n  // - external first\n  // - LAN-reserved IP range priority\n  // - address value\n  const assignments = interfaceAssignments();\n  if (!assignments.length) {\n    // If we have no assignments (which shouldn't ever happen, we make up a loopback interface)\n    return DEFAULT_ASSIGNMENT;\n  }\n\n  let assignment: GatewayAssignment | null;\n\n  // First, we attempt to probe the default route to a publicly routed IP\n  // This will generally fail if there's no route, e.g. if the network is offline\n  try {\n    const defaultRoute = await probeDefaultRoute();\n    // If this route matches a known assignment, return it without a gateway\n    if (\n      (assignment = matchAssignment(assignments, defaultRoute)) &&\n      !isInternal(assignment)\n    ) {\n      return assignment;\n    }\n  } catch {\n    // Ignore errors, since we have a fallback method\n  }\n\n  // Second, attempt to discover a gateway's DHCP network\n  // Because without a gateway we won't get a reply, we do this in parallel\n  const discoveries = await Promise.allSettled(\n    assignments.map(assignment => {\n      // For each assignment, we send a DHCPDISCOVER packet to its network mask\n      return dhcpDiscover(assignment);\n    })\n  );\n  for (const discovery of discoveries) {\n    // The first discovered gateway is returned, if it matches an assignment\n    if (discovery.status === 'fulfilled' && discovery.value) {\n      const dhcpRoute = discovery.value;\n      if ((assignment = matchAssignment(assignments, dhcpRoute))) {\n        return assignment;\n      }\n    }\n  }\n\n  // As a fallback, we choose the first assignment, since they're ordered by likely candidates\n  // This may return 127.0.0.1, typically as a last resort\n  return { ...assignments[0], gateway: null };\n}\n\nexport function lanNetworkSync(): GatewayAssignment {\n  const subprocessPath = require.resolve('lan-network/subprocess');\n  const { error, status, stdout } = spawnSync(\n    process.execPath,\n    [subprocessPath],\n    {\n      shell: false,\n      timeout: 500,\n      encoding: 'utf8',\n      windowsVerbatimArguments: false,\n      windowsHide: true,\n    }\n  );\n  if (status || error) {\n    return DEFAULT_ASSIGNMENT;\n  } else if (!status && typeof stdout === 'string') {\n    const json = JSON.parse(stdout.trim()) as GatewayAssignment;\n    return typeof json === 'object' && json && 'address' in json\n      ? json\n      : DEFAULT_ASSIGNMENT;\n  } else {\n    return DEFAULT_ASSIGNMENT;\n  }\n}\n"],"names":["DEFAULT_ASSIGNMENT","iname","address","netmask","family","mac","internal","cidr","gateway","parseMacStr","macStr","split","slice","map","seq","parseInt","parseIpStr","ipStr","addr","getSubnetPriority","startsWith","isInternal","assignment","every","x","interfaceAssignments","candidates","interfaces","os","networkInterfaces","assignments","push","sort","a","b","priorityA","priorityB","matchAssignment","rawAddr","candidate","candidateAddr","mask","DHCPTimeoutError","TypeError","code","dhcpDiscover","Promise","resolve","reject","broadcastAddress","MASK","toString","toIpStr","computeBroadcastAddress","packet","MAC_ADDRESS","Uint8Array","set","XID","randomBytes","dhcpDiscoverPacket","timeout","setTimeout","socket","createSocket","type","reuseAddr","_msg","rinfo","clearTimeout","close","unref","on","error","bind","setBroadcast","setSendBufferSize","length","send","DefaultRouteError","probeDefaultRoute","connect","async","lanNetwork","defaultRoute","discoveries","allSettled","discovery","status","value","lanNetworkSync","subprocessPath","require","stdout","spawnSync","process","execPath","shell","encoding","windowsVerbatimArguments","windowsHide","json","JSON","parse","trim"],"mappings":"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"}